<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.2.2" />
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
}

strong {
  font-weight: bold;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1 {
  border-bottom: 2px solid silver;
}
h2 {
  border-bottom: 2px solid silver;
  padding-top: 0.5em;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.1em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble,
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-right: 10%;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock {
  margin-right: 0%;
}
div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock > div.content {
  padding-left: 2.0em;
}

div.attribution {
  text-align: right;
}
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.verseblock div.content {
  white-space: pre;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: italic;
}
dd > *:first-child {
  margin-top: 0;
}

ul, ol {
    list-style-position: outside;
}
ol.olist2 {
  list-style-type: lower-alpha;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}

div.hlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hlist td {
  padding-bottom: 5px;
}
td.hlist1 {
  vertical-align: top;
  font-style: italic;
  padding-right: 0.8em;
}
td.hlist2 {
  vertical-align: top;
}

@media print {
  div#footer-badges { display: none; }
}

div#toctitle {
  color: #527bbd;
  font-family: sans-serif;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-content {
  padding-left: 2.0em;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}

/* IE6 sets dynamically generated links as visited. */
div#toc a:visited { color: blue; }
</style>
<title>ZSH-LOVERS(1)</title>
</head>
<body>
<div id="header">
<h1>ZSH-LOVERS(1)</h1>
</div>
<h2>NAME</h2>
<div class="sectionbody">
<p>zsh-lovers - tips, tricks and examples for the Z shell</p>
</div>
<h2>SYNOPSIS</h2>
<div class="sectionbody">
<p>Just read it. ;-)</p>
</div>
<h2>OVERVIEW</h2>
<div class="sectionbody">
<p>Whenever we look at the zsh manual we wonder why there are no examples or those
simply things in (shell) life.  The zsh contains many features, but there was no
manpage with some examples (like procmailex(5)).  That's why we wrote this
manpage.</p>
<p>Most of the tricks and oneliner come from the mailinglists zsh-users,
zsh-workers, google, newsgroups and from ourself.  See section <strong>LINKS</strong> for
details.</p>
<p>Note: This manpage (zsh-lovers(1)) is <strong>not</strong> an offical part of the Z shell! It's
just a just for fun - manpage ;)<br />
For comments, bugreports and feedback take a quick look at the section <strong>BUGS</strong>.</p>
</div>
<h2>SHELL-SCRIPTING</h2>
<div class="sectionbody">
<p>This section provides some examples for often needed shellscript-stuff. Notice
that you should not use otherwise most examples won't work.<br />
Parse options in shellscripts. Example taken from ZWS by Adam Chodorowski
(<a href="http://www.chodorowski.com/projects/zws/">http://www.chodorowski.com/projects/zws/</a>):</p>
<div class="listingblock">
<div class="content">
<pre><tt>parse_options()
{
    o_port=(-p 9999)
    o_root=(-r WWW)
    o_log=(-d ZWS.log)

    zparseopts -K -- p:=o_port r:=o_root l:=o_log h=o_help
    if [[ $? != 0 || "$o_help" != "" ]]; then
        echo Usage: $(basename "$0") "[-p PORT] [-r DIRECTORY]"
        exit 1
    fi

    port=$o_port[2]
    root=$o_root[2]
    log=$o_log[2]

    if [[ $root[1] != '/' ]]; then root="$PWD/$root"; fi
}
# now use the function:
parse_options $*</tt></pre>
</div></div>
</div>
<h2>EXAMPLES</h2>
<div class="sectionbody">
<p>Available subsections are <strong>Aliases</strong>, <strong>Completion</strong>, <strong>Unsorted/Misc examples</strong>,
<strong>(Recursive) Globbing - Examples</strong>, <strong>Modifiers usage</strong>, <strong>Redirection-Examples</strong>,
<strong>ZMV-Examples</strong> and <strong>Module-Examples</strong>.</p>
<h3>ALIASES</h3>
<p>Suffix aliases are supported in zsh since version 4.2.0. Some examples:</p>
<div class="listingblock">
<div class="content">
<pre><tt>alias -s tex=vim
alias -s html=w3m
alias -s org=w3m</tt></pre>
</div></div>
<p>Now pressing return-key after entering <em>foobar.tex</em> starts vim with
foobar.tex. Calling a html-file runs browser w3m. <em>www.zsh.org</em> and pressing
enter starts w3m with argument www.zsh.org.<br />
Global aliases can be used anywhere in the command line. Example:</p>
<div class="listingblock">
<div class="content">
<pre><tt>$ alias -g C='| wc -l'
$ grep alias ~/.zsh/* C
443</tt></pre>
</div></div>
<p>Some more or less useful global aliases (choose whether they are useful  or not
for you on your own):</p>
<div class="listingblock">
<div class="content">
<pre><tt>alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'
alias -g CA="2&gt;&amp;1 | cat -A"
alias -g C='| wc -l'
alias -g D="DISPLAY=:0.0"
alias -g DN=/dev/null
alias -g ED="export DISPLAY=:0.0"
alias -g EG='|&amp; egrep'
alias -g EH='|&amp; head'
alias -g EL='|&amp; less'
alias -g ELS='|&amp; less -S'
alias -g ETL='|&amp; tail -20'
alias -g ET='|&amp; tail'
alias -g F=' | fmt -'
alias -g G='| egrep'
alias -g H='| head'
alias -g HL='|&amp; head -20'
alias -g Sk="*~(*.bz2|*.gz|*.tgz|*.zip|*.z)"
alias -g LL="2&gt;&amp;1 | less"
alias -g L="| less"
alias -g LS='| less -S'
alias -g MM='| most'
alias -g M='| more'
alias -g NE="2&gt; /dev/null"
alias -g NS='| sort -n'
alias -g NUL="&gt; /dev/null 2&gt;&amp;1"
alias -g PIPE='|'
alias -g R=' &gt; /c/aaa/tee.txt '
alias -g RNS='| sort -nr'
alias -g S='| sort'
alias -g TL='| tail -20'
alias -g T='| tail'
alias -g US='| sort -u'
alias -g VM=/var/log/messages
alias -g X0G='| xargs -0 egrep'
alias -g X0='| xargs -0'
alias -g XG='| xargs egrep'
alias -g X='| xargs'</tt></pre>
</div></div>
<h3>COMPLETION</h3>
<p>See also man 1 zshcompctl zshcompsys zshcompwid. zshcompctl is the old
style of zsh programmable completion, zshcompsys is the new completion
system, zshcompwid are the zsh completion widgets.</p>
<p>Some functions, like _apt and _dpkg, are very slow. You can use a cache
in order to proxy the list of  results  (like  the  list  of  available
debian packages) Use a cache:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache</tt></pre>
</div></div>
<p>Prevent CVS files/directories from being completed:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*:(all-|)files' ignored-patterns '(|*/)CVS'
zstyle ':completion:*:cd:*' ignored-patterns '(*/)#CVS'</tt></pre>
</div></div>
<p>Fuzzy matching of completions for when you mistype them:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*' completer _complete _match _approximate
zstyle ':completion:*:match:*' original only
zstyle ':completion:*:approximate:*' max-errors 1 numeric</tt></pre>
</div></div>
<p>And  if  you  want  the  number  of  errors  allowed by _approximate to
increase with the length of what you have typed so far:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle -e ':completion:*:approximate:*' \
        max-errors 'reply=($((($#PREFIX+$#SUFFIX)/3))numeric)'</tt></pre>
</div></div>
<p>Ignore completion functions for commands you don't have:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*:functions' ignored-patterns '_*'</tt></pre>
</div></div>
<p>With helper functions like:</p>
<div class="listingblock">
<div class="content">
<pre><tt>xdvi() { command xdvi ${*:-*.dvi(om[1])} }</tt></pre>
</div></div>
<p>you can avoid having to complete at all in many cases, but if  you  do,
you  might want to fall into menu selection immediately and to have the
words sorted by time:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*:*:xdvi:*' menu yes select
zstyle ':completion:*:*:xdvi:*' file-sort time</tt></pre>
</div></div>
<p>Completing process IDs with menu selection:</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*:*:kill:*' menu yes select
zstyle ':completion:*:kill:*'   force-list always</tt></pre>
</div></div>
<p>If you end up using a directory  as  argument,  this  will  remove  the
trailing slash (usefull in ln)</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*' squeeze-slashes true</tt></pre>
</div></div>
<p>cd will never select the parent directory (e.g.: cd ../&lt;TAB&gt;):</p>
<div class="listingblock">
<div class="content">
<pre><tt>zstyle ':completion:*:cd:*' ignore-parents parent pwd</tt></pre>
</div></div>
<p>Another method for <em>quick change directories</em>. Add this to your ~/.zshrc, then just enter
&#8220;cd &#8230;./dir&#8221;</p>
<div class="listingblock">
<div class="content">
<pre><tt>rationalise-dot() {
  if [[ $LBUFFER = *.. ]]; then
    LBUFFER+=/..
  else
    LBUFFER+=.
  fi
}
zle -N rationalise-dot
bindkey . rationalise-dot</tt></pre>
</div></div>
<h3>UNSORTED/MISC examples</h3>
<p>Hint: A list of valid glob Qualifiers can be found in zshexpn(1).
See &#8220;man 1 zshexpn | less -p&#8221; Qualifiers for details.</p>
<div class="listingblock">
<div class="content">
<pre><tt># random numbers
  $ echo $[${RANDOM}%1000]     # random between 0-999
  $ echo $[${RANDOM}%11+10]    # random between 10-20
  $ echo ${(l:3::0:)${RANDOM}} # N digits long (3 digits)

# reverse a word
  $ echo "${(j::)${(@Oa)${(s::):-hello}}}"

# Show newest directory
  $ ls -ld *(/om[1])

# random array element
  $ FILES=( .../files/* )
  $ feh $FILES[$RANDOM%$#FILES+1]

# cat first line in all files in this dir
  $ for file (*(ND-.)) IFS= read -re &lt; $file

# test if a parameter is numeric
  $ if [[ $1 == &lt;-&gt; ]] ; then
         echo numeric
    else
         echo non-numeric
    fi

# Show me all the .c files for which there doesn't exist a .o file.
  $ print *.c(e_'[[ ! -e $REPLY:r.o ]]'_)

# All files in /var/ that are not owned by root
  $ ls -ld /var/*(^u:root)

# All files for which the owner hat read and execute permissions
  $ echo *(f:u+rx:)

# The same, but also others dont have execute permissions
  $ echo *(f:u+rx,o-x:)

# brace expansion - example
  $ X=(A B C)
  $ Y=(+ -)
  $ print -r -- $^X.$^Y
  A.+ A.- B.+ B.- C.+ C.-

# Fetch the newest file containing the string 'fgractg*.log' in the
# filename and contains the string 'ORA-' in it
  $ file=(fgractg*.log(Nm0om[1]))
  $ (($#file)) &amp;&amp; grep -l ORA- $file
  # without Zsh
  $ files=$( find . -name . -o -prune -name 'fgractg*&gt;log' -mtime 0 -print )
  &gt; if [ -n "$files" ]; then
  &gt;    IFS='
  &gt; '
  &gt; set -f
  &gt; file=$(ls -td $files | head -1)
  &gt; grep -l ORA- "$file"
  &gt; fi

# keep specified number of child processes running until entire task finished
  $ zsh -c 'sleep 1 &amp; sleep 3 &amp; sleep 2&amp; print -rl -- $jobtexts'

# Remove zero length and .bak files in a directory
  $ rm -i *(.L0) *.bak(.)

# print out files that dont have extensions
  $ printf '%s\n' ^?*.*
  $ printf '%s\n' ^?*.[^.]*(D)
  $ ls -d -- ^?*.*(D)

# Finding files which does not contain a specific string
  $ print -rl file* | comm -2 -3 - &lt;(grep -l string file*)'
  $ for f (file*(N)) grep -q string $f || print -r $f'

# Show/Check whether a option is set or not. It works both with $options as
# with $builtins
  $ echo $options[correct]
  off
  $ $options[zle]
  on

# Count the number of directories on the stack
  $ print $((${${(z)${(f)"$(dirs -v)"}[-1]}[1]} + 1)) # or
  $ dirs -v | awk '{n=$1}END{print n+1}'

# Matching all files which do not have a dot in filename
  $ ls *~*.*(.)

# Show only the ip-address from ``ifconfig device''
  # ifconfig from net-tools (Linux)
  $ print ${${$(LC_ALL=C /sbin/ifconfig eth0)[7]}:gs/addr://}
  # ifconfig from 4.2BSD {Free,Net,Open}BSD
  $ print ${$(/sbin/ifconfig tun0)[6]}

# Ping all the IP addresses in a couple of class C's or all hosts
# into /etc/hosts
  $ for i in {1..254}; do ping -c 1 192.168.13.$i; done
  or
  $ I=1
  $ while ( [[ $I -le 255 ]] ) ; do ping -1 2 150.150.150.$I; let I++; done
  or
  $ for i in $(sed 's/#.*//' &gt; /etc/hosts | awk '{print $2}')
  : do
  :    echo "Trying $i ... "
  :    ping -c 1 $i ;
  :    echo '============================='
  : done

# load all available modules at startup
  $ typeset -U m
  $ m=()
  $ for md ($module_path) m=($m $md/**/*(*e:'REPLY=${REPLY#$md/}'::r))
  $ zmodload -i $m

# Rename all files within a directory such that their names get a numeral
# prefix in the default sort order.
  $ i=1; for j in *; do mv $j $i.$j; ((i++)); done
  $ i=1; for f in *; do mv $f $(echo $i | \
    awk '{ printf("%03d", $0)}').$f; ((i++)); done
  $ integer i=0; for f in *; do mv $f $[i+=1].$f; done

# Find (and print) all symbolic links without a target within the current
# dirtree.
  $ $ file **/*(D@) | fgrep broken
  $ for i in **/*(D@); [[ -f $i || -d $i ]] || echo $i
  $ echo **/*(@-^./=%p)
  $ print -l **/*(-@)

# List all plain files that do not have extensions listed in `fignore'
  $ ls **/*~*(${~${(j/|/)fignore}})(.)
  # see above, but now omit executables
  $ ls **/*~*(${~${(j/|/)fignore}})(.^*)

# Print out files that dont have extensions (require *setopt extendedglob*
# and *setopt dotglob*)
  $ printf '%s\n' ^?*.*

# List files in reverse order sorted by name
  $ print -rl -- *(On)
  or
  $ print -rl -- *(^on)

# Synonymic to ``ps ax | awk '{print $1}'''
  $ print -l /proc/*/cwd(:h:t:s/self//)

# Get the PID of a process (without ``ps'', ``sed'', ``pgrep'', ..
# (under Linux)
  $ pid2 () {
  &gt;   local i
  &gt;   for i in /proc/&lt;-&gt;/stat
  &gt; do
  &gt;   [[ "$(&lt; $i)" = *\((${(j:|:)~@})\)* ]] &amp;&amp; echo $i:h:t
  &gt; done
  &gt; }

# for X in 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y'; do ...
  $ for (( i = 36#n; i &lt;= 36#y; i++ )); do
  &gt;   print ${$(([##36]i)):l}
  &gt; done
# or in combination with ``dc''
  $ print {$((##n))..$((##y))}P\ 10P | dc
# or with ``eval''
  $ eval print '${$(([##36]'{$((36#n))..$((36#y))}')):l}'

# foreach in one line of shell
  $ for f (*) print -r -- $f

# copy a directory recursively without data/files
  $ dirs=(**/*(/))
  $ cd -- $dest_root
  $ mkdir -p -- $dirs
# or without zsh
  $ find . -type d -exec env d="$dest_root" \
    sh -c ' exec mkdir -p -- "$d/$1"' '{}' '{}' \;

# If `foo=23'', then print with 10 digit with leading '0'.
  $ foo=23
  $ print ${(r:10::0:)foo}

# find the name of all the files in their home directory that have
# more than 20 characters in their file names
  print -rl $HOME/${(l:20::?:)~:-}*

# Save arrays
  $ print -r -- ${(qq)m} &gt; $nameoffile      # save it
  $ eval "m=($(cat -- $nameoffile)"            # or use
  $ m=("${(@Q)${(z)"$(cat -- $nameoffile)"}}") # to restore it

# get a "ls -l" on all the files in the tree that are younger than a
# specified age (e.g "ls -l" all the files in the tree that where
# modified in the last 2 days)
  $ ls -tld **/*(m-2)
# This will give you a listing 1 file perl line (not Ã  la ls -R).
# Think of an easy way to have a "ls -R" style output with
# only files newer than 2 day old.
  $ for d (. ./**/*(/)) {
  &gt;   print -r -- $'\n'${d}:
  &gt;   cd $d &amp;&amp; {
  &gt;       l=(*(Nm-2))
  &gt;       (($#l)) &amp;&amp; ls -ltd -- $l
  &gt;       cd ~-
  &gt;   }
  &gt; }
# If you also want directories to be included even if their mtime
# is more than 2 days old:
  $ for d (. ./**/*(/)) {
  &gt;   print -r -- $'\n'${d}:
  &gt;   cd $d &amp;&amp; {
  &gt;      l=(*(N/,m-2))
  &gt;      (($#l)) &amp;&amp; ls -ltd -- $l
  &gt;      cd ~-
  &gt;   }
  &gt; }
# And if you want only the directories with mtime &lt; 2 days to be listed:
  $ for d (. ./**/*(N/m-2)) {
  &gt;   print -r -- $'\n'${d}:
  &gt;   cd $d &amp;&amp; {
  &gt;      l=(*(Nm-2))
  &gt;      (($#l)) &amp;&amp; ls -ltd -- $l
  &gt;      cd ~-
  &gt;   }
  &gt; }

# print 42 ``-''
  $ echo ${(l:42::-:)}
# or use ``$COLUMS''
  $ echo ${(l:$COLUMNS::-:)}
# and now with colors (require autoload colors ;colors)
  $ echo "$bg[red]$fg[black]${(l:42::-:)}"

# Redirect STDERR to a command like xless without redirecting STDOUT as well.
  $ foo 2&gt;&gt;(xless)
# but this executes the command asynchronously. To do it synchronously:
  $ { { foo 1&gt;&amp;3 } 2&gt;&amp;1 | xless } 3&gt;&amp;1

# Rename all MP3-Files from name with spaces.mp3 to Name With Spaces.mp3
  $ for i in *.mp3; do
  &gt;     mv $i ${${(C)i}:s/Mp3/mp3/}
  &gt; done

# Match file names containing only digits and ending with .xml (require
# *setopt kshglob*)
  $ ls -l [0-9]##.xml
  $ ls -l &lt;0-&gt;.xml

# Remove all "non txt" files
  $ rm ./^*.txt

# Move 200 files from a directory into another
  $ mv -- *([1,200]) /another/Dir

# Convert images (foo.gif =&gt; foo.png):
  $ for i in **/*.gif; convert $i $i:r.png

# convert a collection of mp3 files to wave or cdr,
# e.g. file.wav -&gt; file.mp3)
  $ for i (./*.mp3){mpg321 --w - $i &gt; ${i:r}.wav}

# Download with LaTeX2HTML  created Files (for example the ZSH-Guide):
  $ for f in http://zsh.sunsite.dk/Guide/zshguide{,{01..08}}.html; do
  &gt;     lynx -source $f &gt;${f:t}
  &gt; done

# Move all files in dir1 and dir2 that have line counts greater than 10 to
# another directory say "/more10"
  $ mv dir[12]/**/*.cr(-.e{'((`wc -l &lt; $REPLY` &gt; 10))'}) /more10

# Make with dpkg a master-list of everyfile that it has installed
  $ diff &lt;(find / | sort) &lt;(cat /var/lib/dpkg/info/*.list | sort)

# Replace this fucking Escape-Sequences:
  $ autoload colors ; colors
  $ print "$bg[cyan]$fg[blue]You are a idiot" &gt;&gt; /dev/pts/3

# Get ASCII value of a character
  $ char=N ; print $((#char))

# Filename "Erweiterung"
# Note: The (N) says to use the nullglob option for this particular
# glob pattern.
  $ for i in *.o(N); do
  &gt;     rm $i
  &gt; done

# Rename files; i. e. FOO to foo and bar to BAR
  $ for i in *(.); mv $i ${i:l} # `FOO' to `foo'
  $ for i in *(.); mv $i ${i:u} # `bar to `BAR'

# Show all suid-files in $PATH
  $ ls -latg ${(s.:.)PATH} | grep '^...s'
# or more complex ;)
  $ print -l ${^path}/*(Ns,S)
# or show only executables with a user given pattern
  $ print -l ${^path}/*vim*(*N)

# gzip files when containing a certain string
  $ gzip ${(ps:\0:)"$(grep -lZ foobar ./*.txt(.))"}

# A small  one-liner, that reads from stdin and prints to stdout the first
# unique line i. e. does not print lines that have been printed before
# (this is similar to the unique command, but unique can only handle
# adjacent lines).
  $ IFS=$'\n\n'; print -rl -- ${(Oau)${(Oa)$(cat file;echo .)[1,-2]}}

# Lists every executable in PATH
  $ print -l ${^path}/*(-*N)

# Match all .c files in all subdirectories, _except_ any SCCS subdirectories?
  $ ls **/*.c~(*/)#SCCS/*

# List all `README' - files case-insensitive with max. one typo
  $ ls **/*(#ia2)readme

# case insensitive checking for variables
  $ if [[ $OSTYPE == (#i)LINUX*(#I) ]]; then
  &gt;    echo "Penguin on board."
  &gt; else
  &gt;    echo "Not a Linux."
  &gt; fi</tt></pre>
</div></div>
<h3>(Recursive) Globbing - Examples</h3>
<p>A list of valid glob Qualifiers can be found in zshexpn(1). <strong>Note:</strong>
**/ is equivalent to (*/)#! For example:</p>
<div class="listingblock">
<div class="content">
<pre><tt>$ print (*/)#zsh_us.ps
zsh-4.2.3/Doc/zsh_us.ps
$ print **/zsh_us.ps
zsh-4.2.3/Doc/zsh_us.ps</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt># Search for `README' in all Subdirectories
  $ ls -l **/README

# find directories that contain both "index.php" and "index.html", or in
# general, directories that contain more than one file matching "index.*"
  $ ls **/*(D/e:'[[ -e $REPLY/index.php &amp;&amp; -e $REPLY/index.html ]]':)
  # or
  $ ls **/*(D/e:'l=($REPLY/index.*(N)); (( $#l &gt;= 2 ))':)

# Find command to search for directory name instead of basename
  $ print -rl /**/*~^*/path(|/*)
  # or - without Zsh
  $ find / | grep -e /path/ -e '/path$'

# Print he path of the directories holding the ten biggest C regular files
# in the current directory and subdirectories.
  $ print -rl -- **/*.c(D.OL[1,10]:h) | sort -u

# Find files with size == 0 and send a mail
  $ files=(**/*(ND.L0m+0m-2))
  &gt; (( $#files &gt; 0 )) &amp;&amp; print -rl -- $files | \
    mailx -s "empty files" foo@bar.tdl

# recursive chmod
  $ chmod 700 **/(.) # Only files
  $ chmod 700 **/(/) # Only directories

# print out all of the files in that directory in 2 columns
  $ print -rC2 -- ${1:[...]}/*(D:t)
#            ^- number ob columns
# or - if you feel concerned about special characters - use
  $ list=(${1:[...]}/*(ND:t))
  $ (($#list)) &amp;&amp; print -rC2 -- ${(V)list}

# Search all files in /home/*/*-mail/ with a setting ``chmod -s'' flag
# (recursive, include  dotfiles) remove the setgid/setuid flag and print
# a message
  $ chmod -s /home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S))
# or with a small script
  $ for file (/home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S)) {
  &gt;    print -r -- $file
  &gt;    chmod -s $file &amp;&amp; print -r fixed $file
  &gt; }
# or use ``zargs'' (require autoload zargs) prevent the arg list too
# long error
  $ zargs /home/*/*-mail(DNs,S) /home/*/*-mail/**/*(DNs,S)) -- chmod -s

# List files beginning at `foo23' upwards (foo23, foo24, foo25, ..)
  $ ls -l foo&lt;23-&gt;

# get all files that begin with the date strings from June 4 through
# June 9 of 2004
  $ ls -l 200406{04..10}*(N)
# or if they are of the form 200406XX (require ``setopt extended_glob''
  $ ls -l 200306&lt;4-10&gt;.*

# remove spaces from filenames
  $ for a in ./**/*\ *(Dod); do mv $a ${a:h}/${a:t:gs/ /_}; done

# Show only all *.c and *.h - Files
  $ ls -l *.(c|h)

# Show only all *.c - files and ignore `foo.c'
  $ ls *.c~foo.c

# show data to *really* binary format
  $ zsh -ec 'while {} {printf %.8x $n;repeat 8 \
  &gt; {read -ku0 a printf \ %.8d $(([##2]#a))};print;((n+=8))}' &lt; binary

# Show only world-readable files
  $ ls -l *(R)

# List files in the current directory are not writable by the owner
  $ print -l ~/*(ND.^w)

# find and delete the files which are older than a given parameter
# (seconds/minutes/hours)
  # deletes all regular file in /Dir that are older than 3 hours
   $ rm -f /Dir/**/*(.mh+3)
  # deletes all symlinks in /Dir that are older than 3 minutes
   $ rm -f /Dir/**/*(@mm+3)
  # deletes all non dirs in /Dir that are older than 30 seconds
   $ rm -f /Dir/**/*(ms+30^/)
  # deletes all folders, sub-folders and files older than one hour
   $ rm ./**/*(.Dmh+1,.DL0)
  # deletes all files more than 6 hours old
   $ rm -f **/*(mh+6)
  # removes all files but the ten newer ones (delete all but last 10
  # files in a directory)
   $ rm ./*(Om[1,-11])
 Note: If you get a arg list too long, you use the builtin rm. For
       example:
   $ zmodload zsh/files ; rm -f **/*(mh+6)
  or use the zargs function:
   $ autoload zargs ; zargs **/*(mh+6) -- rm -f

# A User's Guide to the Z-Shell /5.9: Filename Generation and Pattern
# Matching find all files in all subdirectories, searching recursively,
# which have a given name, case insensitive, are at least 50 KB large,
# no more than a week old and owned by the root user, and allowing up
# to a single error in the spelling of the name. In fact, the required
# expression looks like this:
  $ ls **/(#ia1)name(LK+50mw-1u0)

# Change the UID from 102 to 666
  $ chown 666 **/*(u102)

# List all files which have not been updated since last 10 hours
  $ print -rl -- *(Dmh+10^/)

# delete only the oldest file in a directory
  $ rm ./*filename*(Om[1])

# Sort the output from `ls -l' by file size
  $ ls -fld *(OL)

# find most recent file in a directory
  $ setopt dotglob ; print directory/**/*(om[1])

# Show only empty files which nor `group' or `world writable'
  $ ls *(L0f.go-w.)

# find - and list - the ten newest files in directories and subdirs
# (recursive)
  $ print -rl -- **/*(Dom[1,10])

# Print only 5 lines by "ls" command (like ``ls -laS | head -n 5'')
  $ ls -fl *(DOL[1,5])

# display the 5-10 last modified files
  $ print -rl -- /path/to/dir/**/*(D.om[5,10])

# find all files without a valid owner
  $ chmod someuser /**/*(D^u:${(j.:u:.)${(f)"$(&lt;/etc/passwd)"}%%:*}:)

# find all the empty directories in a tree
  $ for f in ***/*(/l2); do foo=($f/*(N)); [[ -z $foo ]] &amp;&amp; print $f; done
# Note:Since Zsh 4.2.1 the glob qualifier F indicates a non-empty directory.
# Hence *(F) indicates all subdirectories with entries, *(/^F) means all
# subdirectories with no entries.
  $ ls -ld *(/^F)

# remove empty directories afterwards
  $ rmdir ./**/*(/od) 2&gt; /dev/null

# Show only files are owned from group `users'
  $ ls -l *(G[users])
</tt></pre>
</div></div>
<h3>Modifiers usage</h3>
<p>Modifiers are a powerful mechanism that let you modify the results
returned by parameter, filename and history expansion. See zshexpn(1)
for details.</p>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;&lt;&lt;&lt;&lt;&lt;&lt; /home/dope/download/Source/HG-Repos/zsh-lovers/zsh-lovers.1.txt.orig.432616858
# NOTE: Zsh 4.3.4 needed!
$ autoload -U age
# files modified today
  $ print *(e:age today now:)
# files modified since 5 pm
  $ print *(e-age 17:00 now-)
# ... since 5 o'clock yesterda
  $ print *(e-age yesterday,17:00 now-)
# ... from last Christmas before today
  $ print *(e-age 2006/12/25 today-)
# ... before yesterday
  $ print *(e-age 1970/01/01 yesterday-)
# all files modified between the start of those dates
  $ print *(e:age 2006/10/04 2006/10/09:)
# all files modified on that date
  $ print *(e:age 2006/10/04:)
# Supply times.
  $ print *(e-age 2006/10/04:10:15 2006/10/04:10:45-)

# Remove a trailing pathname component, leaving the head. This works like
||||||| /tmp/zsh-lovers.1.txt~base.AvW_ZW
# Remove a trailing pathname component, leaving the head. This works like
=======
# Remove a trailing pathname component, leaving the head. This works like
&gt;&gt;&gt;&gt;&gt;&gt;&gt; /tmp/zsh-lovers.1.txt~other.vDaddL
# `dirname'.
  $ echo =ls(:h)
  /bin

# Remove all leading pathname components, leaving the tail. This works
# like `basename'.
  $ echo =ls(:t)
  ls

# Remove the suffix from each file (*.sh in this example)
   $f:e is $f file extension
   :h --&gt; head (dirname)
   :t --&gt; tail (basename)
   :r --&gt; rest (extension removed)
  $ for f (*.sh) mv $f $f:r

# Remove a filename extension of the form `.xxx', leaving the root name.
  $ echo $PWD
  /usr/src/linux
  $ echo $PWD:t
  linux

# Remove all but the extension.
  $ foo=23.42
  $ echo $foo
  23.42
  $ echo $foo:e
  42

# Print the new command but do not execute it. Only works with history
# expansion.
  $ echo =ls(:h)
  /bin
  $ !echo:p
  $ echo =ls(:h)

# Quote the substituted words, escaping further substitutions.
  $ bar="23'42"
  $ echo $bar
  23'42
  $ echo $bar:q
  23\'42

# Convert the words to all lowercase.
  $ bar=FOOBAR
  $ echo $bar
  FOOBAR
  $ echo $bar:l
  foobar

# Convert the words to all uppercase.
  $ bar=foobar
  $ echo $bar
  foobar
  $ echo $bar:u
  FOOBAR

# convert 1st char of a word to uppercase
  $ foo="one two three four"
  $ print -r -- "${(C)foo}"
  One Two Three Four</tt></pre>
</div></div>
<h3>Redirection-Examples</h3>
<p>See zshmisc(1) for more informations (or less ${^fpath}/zmv(N))</p>
<div class="listingblock">
<div class="content">
<pre><tt># Append `exit 1' at the end of all *.sh - files
  $ echo "exit 1" &gt;&gt; *.sh

# adding files to foobar.tar.gz
  $ eval set =(gunzip &lt; foobar.tar.gz) '
     tar rf $1 additional.txt &amp;&amp;gzip &lt; $1 &gt; foobar.tar.gz'

# Redirect output to a file AND display on screen
  $ foobar &gt;&amp;1 &gt; file1 &gt; file2 &gt; ..

# pipe single output to multiple inputs
  $ zcat foobar.Z &gt;&gt; (gzip -9 &gt; file1.gz) \
      &gt;&gt; (bzip2 -9 &gt; file1.bz2) \
      &gt;&gt; (acb --best &gt; file1.acb)

# Append /etc/services at the end of file `foo' and `bar'
  $ cat /etc/services &gt;&gt; foo &gt;&gt; bar

# Pipe STDERR
  $ echo An error &gt;&amp;2 2&gt;&amp;1 | sed -e 's/A/I/'

# send standard output of one process to standard input of several processes
# in the pipeline
  $ setopt multios
  $ process1 &gt; &gt;(process1) &gt; &gt;(process2)

# initializing a variable and simultaneously keeping terminal output
  $ setopt multios
  $ { a=$(command &gt;&amp;1 &gt;&amp; 3 3 &gt; &amp;- 2&gt;&amp;1);} 3&gt;&amp;1

# redirect stderr two times
  $ setopt multios ; program 2&gt; file2 &gt; file1 2&gt;&amp;1

# Duplicating stdout and stderr to a logfile
  $ exec 3&gt;&amp;1 &gt; logfile 2&gt;&amp;2 2&gt;&amp;1 &gt;&amp;3 3&gt;&amp;-

# redirect stderr (only) to a file and to orig. stderr:
  $ command 2&gt;&amp;2 2&gt;stderr
# redirect stderr and stdout to separate files and both to orig. stdout:
  $ command 2&gt;&amp;1 1&gt;&amp;1 2&gt;stderr 1&gt;stdout
# redirect stderr and stdout to separate files and stdout to orig. stdout
# AND stderr to orig. stderr:
  $ command 2&gt;&amp;2 1&gt;&amp;1 2&gt;stderr 1&gt;stdout

# More fun with STDERR ;)
  $ ./my-script.sh 2&gt; &gt;(grep -v moron &gt;error.log)|process-output &gt;output.log
  $  echo "Thats STDOUT" &gt;&gt;(sed 's/stdout/another example/' &gt; foobar)</tt></pre>
</div></div>
<h3>ZMV-Examples (require autoload zmv)</h3>
<p><strong>Note:</strong> <em>-n</em> means no execution (just print what would happen). At</p>
<div class="listingblock">
<div class="content">
<pre><tt># remove round bracket within filenames
# i. e. foo-(bar).avi -&gt; foo-bar.avi
  $ zmv '*' '${f//[()]/}'

# serially all files (foo.foo &gt; 1.foo, fnord.foo &gt; 2.foo, ..)
  $ autoload zmv
  $ ls *
  1.c  asd.foo  bla.foo  fnord.foo  foo.fnord  foo.foo
  $ c=1 zmv '*.foo' '$((c++)).foo'
  $ ls *
  1.c  1.foo  2.foo  3.foo  4.foo  foo.fnord

# Rename "file.with.many.dots.txt" by substituting dots (exept for the last
# one!) with a space
  $ touch {1..20}-file.with.many.dots.txt
  $ zmv '(*.*)(.*)' '${1//./ }$2'

# Remove the first 4 chars from a filename
  $ zmv -n '*' '$f[5,-1]' # NOTE: The "5" is NOT a mistake in writing!

# Rename names of all files under the current Dir to lower case, but keep
# dirnames as-is.
  $ zmv -Qv '(**/)(*)(.D)' '$1${(L)2}'

# replace all 4th character, which is "1",  with "2" and so on
  $ autoload -U zmv
  $ zmv '(???)1(???[1-4].txt)' '${1}2${2}'

# Remove the first 15 characters from a string
  $ touch 111111111111111{a-z}
  $ autoload zmv
  $ zmv '*' '$f[16,-1]'

# Replace spaces (any number of them) with a single dash in file names
  $ autload zmv
  $ zmv -n '(**/)(* *)' '$1${2//( #-## #| ##)/-}'
  # or - with Bash
  $ find . -depth -name '* *' -exec bash -c '
  &gt; shopt -s extglob
  &gt; file=$1
  &gt; dir=${file%/*}
  &gt; name=${file##*/}
  &gt; newname=${name//*([ -]) *([ -])/-}
  &gt; mv -i -- "$file" "$Dir/$newname"' {} {} \;

# Clean up file names and remove special characters
  $ autoload zmv
  $ zmv -n '(**/)(*)' '$1${2//[^A-Za-z0-9._]/_}'

# Add *.py to a bunch of python scripts in a directory (some of them end
# in *.py and give them all a proper extension
  $ autoload zmv
  $ zmv -n '(**/)(con*)(#qe,file $REPLY | grep "python script",)' '$1$2.py'

# lowercase all extensions (i. e. *.JPG) incl. subfolders
  $ autoload zmv
  $ zmv '(**/)(*).(#i)jpg' '$1$2.jpg'
  # Or - without Zsh
  $ find Dir -name '*.[jJ][pP][gG]' -print | while read f
  &gt; do
  &gt;      case $f in
  &gt;       *.jpg) ;
  &gt;       *) mv "$f" "${f%.*}.jpg" ;
  &gt;       esac
  &gt; done

# remove leading zeros from file extension
  $ autoload zmv
  $ ls
  filename.001  filename.003  filename.005  filename.007  filename.009
  filename.002  filename.004  filename.006  filename.008  filename.010
  $ zmv '(filename.)0##(?*)' '$1$2'
  $ ls
  filename.1  filename.10  filename.2  filename.3  filename.4  filename.5 ..

# renumber files.
  $ autoload zmv
  $ ls *
  foo_10.jpg  foo_2.jpg  foo_3.jpg  foo_4.jpg  foo_5.jpg  foo_6.jpg ..
  $ zmv -fQ 'foo_(&lt;0-&gt;).jpg(.nOn)' 'foo_$(($1 + 1)).jpg'
  $ ls *
  foo_10.jpg  foo_11.jpg  foo_3.jpg  foo_4.jpg  foo_5.jpg  ...

# adding leading zeros to a filename (1.jpg -&gt; 001.jpg, ..
  $ autoload zmv
  $ zmv '(&lt;1-&gt;).jpg' '${(l:3::0:)1}.jpg'

# See above, but now only files with a filename &gt;= 30 chars
  $ autoload zmv
  $ c=1 zmv "${(l:30-4::?:)}*.foo" '$((c++)).foo'

# Replace spaces in filenames with a underline
  $ autoload zmv
  $ zmv '* *' '$f:gs/ /_'

# Change the suffix from *.sh to *.pl
  $ autoload zmv
  $ zmv -W '*.sh' '*.pl'

# Add a "".txt" extension to all the files within ${HOME}
  # ``-.'' is to only rename regular files or symlinks to regular files,
  # ``D'' is to also rename hidden files (dotfiles))
  $ autoload zmv
  $ zmv -Q '/home/**/*(D-.)' '$f.txt'
  # Or to only rename files that don't have an extension:
  $ zmv -Q '/home/**/^?*.*(D-.)' '$f.txt'

# Recursively change filenames with characters ? [ ] / = + &lt; &gt; ; : " , - *
  $ autoload zmv
  $ chars='[][?=+&lt;&gt;;",*-]'
  $ zmv '(**/)(*)' '$1${2//$~chars/%}'

# Removing single quote from filenames (recursively)
  $ autoload zmv
  $ zmv -Q "(**/)(*'*)(D)" "\$1\${2//'/}"

# When a new file arrives (named file.txt) rename all files in order to
# get (e. g. file119.txt becomes file120.txt, file118.txt becomes
# file119.txt and so on ending with file.txt becoming file1.txt
  $ autoload zmv
  $ zmv -fQ 'file([0-9]##).txt(On)' 'file$(($1 + 1)).txt'

# lowercase/uppercase all files/directories
  $ autoload zmv
  $ zmv '(*)' '${(L)1}' # lowercase
  $ zmv '(*)' '${(U)1}' # uppercase

# Remove the suffix *.c from all C-Files
  $ autoload zmv
  $ zmv '(*).c' '$1'

# Uppercase only the first letter of all *.mp3 - files
  $ autoload zmv
  $ zmv '([a-z])(*).mp3' '${(C)1}$2.mp3'

# Copy the target `README' in same directory as each `Makefile'
  $ autoload zmv
  $ zmv -C '(**/)Makefile' '${1}README'

# Removing single quote from filenames (recursively)
  $ autoload zmv
  $ zmv -Q "(**/)(*'*)(D)" "\$1\${2//'/}"

# Rename pic1.jpg, pic2.jpg, .. to pic0001.jpg, pic0002.jpg, ..
  $ autoload zmv
  $ zmv 'pic(*).jpg' 'pic${(l:4::0:)1}.jpg'
  $ zmv '(**/)pic(*).jpg' '$1/pic${(l:4::0:)2}.jpg' # recursively</tt></pre>
</div></div>
<h3>Module-Examples</h3>
<p>Please read zshmodules(1) first!</p>
<h4>zsh/pcre (require zmodload zsh/pcre)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># Copy files of a certain period (date indicated in the filenames)
  $ zmodload zsh/pcre
  $ ls -d -- *(e:'[[ $REPLY -pcre-match pcre-regexp ]]':)
  # or
  $ m() { [[ $1 -pcre-match pcre-regexp ]] }
  $ ls -d -- *(+m)</tt></pre>
</div></div>
<h4>zsh/clone (require zmodload zsh/clone)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># Creates a forked instance of the current shell ($! is set to zero) and
# execute ``command'' on /dev/tty8 (for this example).
  $ zmodload zsh/clone
  $ clone /dev/tty8 &amp;&amp; (($! == 0)) &amp;&amp; exec command</tt></pre>
</div></div>
<h4>zsh/datetime (require zmodload zsh/datetime)</h4>
<div class="listingblock">
<div class="content">
<pre><tt>  $ zmodload zsh/datetime
  $ alias datereplacement='strftime "%Y-%m-%d" $EPOCHSECONDS'
  $ export DATE=`datereplacement`
  $ echo $DATE

#  strip date from filename
  $ $ zmodload zsh/datetime
  $ setopt extendedglob
  $ touch aaa_bbb_20041212_c.dat eee_fff_20051019_g.dat
  $ strftime -s pattern \
    '???_???_&lt;0-%Y%m%d&gt;_?.dat' $((EPOCHSECONDS - 365 * 24 * 60 * 60 / 2))
  $ print -rl -- $~pattern
  aaa_bbb_20041212_c.dat
  $ print -rl -- $pattern
  ???_???_&lt;0-20050815&gt;_?.dat

# Search files size == 0, to be based on the file name containing a date
# rather than the "last modified" date of the file
  $ zmodload -i zsh/datetime
  $ strftime -s file "abc_de_%m%d%Y.dat" $((EPOCHSECONDS - 24 * 60 * 60 ))
  $ files=(**/$file(N.L0))
  $ (( $#files &gt; 0 )) &amp;&amp; print -rl -- $files | \
    mailx -s "empty files"  foo@bar.tdl</tt></pre>
</div></div>
<h4>zsh/stat (require zmodload zsh/stat)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># test if a symbolic link links to a certain file
  $ zmodload -i zsh/stat
  $ ! stat -LH s foo.ln || [[ $s[link] != "foo.exe" ]] || ln -sf foo.exe foo.ln

# comparing file dates
  $ zmodload zsh/stat
  $ file1=foo
  $ file2=bar
  $ touch bar &amp; sleep 5 &amp; touch foo
  $ echo $file1 is $(($(stat +mtime $file2) - \
    $(stat +mtime $file1))) seconds older than $file2.
  bar is 5 seconds older than foo

# list the files of a disk smaller than some other file
  $ zmodload zsh/stat
  $ stat -A max +size some-other-file
  $ print -rl ./**/*(D.L-$max)

# List the top 100 biggest files in a disk
  $ zmodload zsh/stat
  $ ls -fld ./**/*(d`stat +device .`OL[1,100])

# Get only the user name and the file names from (like
# ls -l * | awk '{print $3" " $8}')
  $ zmodload zsh/stat
  $ for file; do
  &gt;   stat -sA user +uid -- "$file" &amp;&amp;
  &gt;     print -r -- "$user" "$file"
  &gt; done

# get the difference between actual bytes of file and allocated bytes of file
  $ zmodload zsh/stat
  $ print $(($(stat +block -- file) * 512 - $(stat +size -- file)))

# Find largest file
# ``D''  : to include dot files (d lowercase is for device)
# ``O''  : reverse Ordered (o lowercase for non-reverse order)
# ``L''  : by file Length (l is for number of links)
# ``[1]'': return only first one
  $ zmodload zsh/stat
  $ stat +size ./*(DOL[1])

# file size in bytes
  $ zmodload zsh/stat
  $ stat -L +size ~/.zshrc
  4707

# Delete files in a directory that hasn't been accessed in the last ten days
# and send ONE mail to the owner of the files informing him/her of the files'
# deletion.
  $ zmodload zsh/stat zsh/files
  $ typeset -A f; f=()
  $ rm -f /path/**/*(.a+10e{'stat -sA u +uidr $REPLY; f[$u]="$f[$u]$REPLY"'})
  $ for user (${(k)f}) {print -rn $f[$user]|mailx -s "..." $user}

# Get a "ls -l" on all the files in the tree that are younger than a
# specified age
  $ zmodload zsh/stat
  $ for d (. ./**/*(N/m-2))
  &gt;   print -r -- $'\n'$d: &amp;&amp; cd $d &amp;&amp; {
  &gt;      for f (*(Nm-2om))
  &gt;   stat -F '%b %d %H:%M' -LsAs -- $f &amp;&amp;
  &gt;   print -r -- $s[3] ${(l:4:)s[4]} ${(l:8:)s[5]} \
  &gt;   ${(l:8:)s[6]} ${(l:8:)s[8]} $s[10] $f ${s[14]:+-&gt; $s[14]}
  &gt;   cd ~-
  &gt; }

# get file creation date
  $ zmodload zsh/stat
  $ stat -F '%d %m %Y' +mtime ~/.zshrc
  30 06 2004
  $ stat -F '%D' +mtime ~/.zshrc
  06/30/04</tt></pre>
</div></div>
<h4>zsh/files (require zmodload zsh/files)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># search a directory for files containing a certain string then copy those
# files to another directory.
  $ zmodload zsh/files
  $ IFS=$'\0'
  $ cp $(grep -lZr foobar .) otherdirectory</tt></pre>
</div></div>
<h4>zsh/mapfile (require zmodload zsh/mapfile)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># grepping for two patterns
  $ zmodload zsh/mapfile
  $ pattern1="foo"
  $ pattern2="bar foo"
  $ print -l ./**/*(DN.e{'z=$mapfile[$REPLY] &amp;&amp; [[ $z = *$pattern1* &amp;&amp; \
    $z = *$pattern2* ]]'})
# or a solution in combination with zsh/pcre
  $ zmodload -i zsh/mapfile zsh/pcre
  $ pattern1="foo"
  $ pattern2="bar foo"
  $ pcre_compile "(?s)(?=.*?$pattern1).*?$pattern2"
  $ pcre_study
  $ print -l ./**/*(DN.e{'pcre_match $mapfile[$REPLY]'})

# equivalent for ``less /etc/passwd | grep -v root''
  $ zmodload zsh/mapfile
  $ IFS=$'\n\n'
  $ print -rl -- ${${=mapfile[/etc/passwd]}:#*root*}
# or - for case insensitive
  $ setopt extendedglob
  $ print -rl -- ${${=mapfile[/etc/passwd]}:#*(#i)root*}

# If a XML-file contains stuff like ``&lt;TAGA/&gt;'' and ``&lt;TAGB/&gt;'', number
# this empty tags (ones ending in '/&gt;') so if encountered in the same
# order, the preceeding tags would become ``&lt;TAGA/&gt;1&lt;/TAGA&gt;'' and
# ``&lt;TAGB/&gt;2&lt;/TAGB&gt;''
  $ zmodload zsh/mapfile
  $ cnt=0
  $ apfile[data.xml.new]=${(S)mapfile[data.xml]//\
  &gt; (#im)&lt;TAGA&gt;*&lt;\/TAGA&gt;/&lt;TAGA&gt;$((++cnt))&lt;\/TAGA&gt;}

# removing all files in users Maildir/new that contain ``filename="gone.src''
  $ zmodload zsh/{files,mapfile}
  $ rm -f /u1/??/*/Maildir/new/100*(.e{'[[ $mapfile[$REPLY] == \
    *filename=\"gone.scr\"* ]]'})

# Grep out the Title from a postscript file and append that value to the
# end of the filename
  $ autoload -U zmv
  $ zmodload zsh/mapfile
  $ zmv '(*).ps' '$1-${${${mapfile[$f]##*%%Title: }%% *}//[^a-zA-Z0-9_]/}.ps'</tt></pre>
</div></div>
<h4>zsh/mathfunc (require zmodload zsh/mathfunc)</h4>
<div class="listingblock">
<div class="content">
<pre><tt>$ zmodload zsh/mathfunc
$ echo $(( sin(1/4.0)**2 + cos(1/4.0)**2 - 1 ))
  -1.1102230246251565e-16
$ echo $(( pi = 4.0 * atan(1.0) ))
  3.1415926535897931
$ echo $(( f = sin(0.3) ))
  0.29552020666133955
$ print $((1e12 * rand48()))
  847909677310.23413
$ print $(( rand48(seed) ))
  0.01043488334700271</tt></pre>
</div></div>
<h4>zsh/termcap (require zmodload zsh/termcap)</h4>
<div class="listingblock">
<div class="content">
<pre><tt> $ zmodload -ab zsh/termcap echotc
 $ GREEN=`echotc AF 2`
 $ YELLOW=`echotc AF 3`
 $ RED=`echotc AF 1`
 $ BRIGHTRED=`echotc md ; echotc AF 1`
 $ print -l ${GREEN}green ${YELLOW}yellow ${RED}red ${BRIGHTRED}brightred</tt></pre>
</div></div>
<h4>zsh/zpty (require zmodload zsh/zpty)</h4>
<div class="listingblock">
<div class="content">
<pre><tt>  $ zmodload zsh/zpty
  $ zpty PW passwd $1
  $ zpty PW passwd $1
# ``-r'': read the output of the command name.
# ``z'' : Parameter
  $ zpty -r PW z '*password:'
# send the to command name the given strings as input
  $ zpty -w PW $2
  $ zpty -r PW z '*password:'
  $ zpty -w PW $2
# The second form, with the -d option, is used to delete commands
# previously started, by supplying a list of their names. If no names
# are given, all commands are deleted. Deleting a command causes the HUP
# signal to be sent to the corresponding process.
  $ zpty -d PW</tt></pre>
</div></div>
<h4>zsh/net/socket (require zmodload zsh/net/socket)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># ``-l'': open a socket listening on filename
# ``-d'': argument will be taken as the target file descriptor for the
#         connection
# ``3'' : file descriptor. See ``A User's Guide to the Z-Shell''
#         (3.7.2: File descriptors)
  $ zmodload zsh/net/socket
  $ zsocket -l -d 3
# ``-a'': accept an incoming connection to the socket
  $ zsocket -a -d 4 3
  $ zsocket -a -d 5 3 # accept a connection
  $ echo foobar &gt;&amp;4
  $ echo barfoo &gt;&amp;5
  $ 4&gt;&amp;- 5&gt;&amp;- 3&gt;&amp;</tt></pre>
</div></div>
<h4>zsh/zftp (require zmodload zsh/zftp)</h4>
<div class="listingblock">
<div class="content">
<pre><tt> $ autoload -U zfinit
 $ zfinit
 $ zfparams www.example.invalid myuserid mypassword
 $ zfopen
 $ zfcd tips
 $ zfls -l zshtips.html
 $ zfput zshtips.html
 $ zfls -l zshtips.html

# Automatically transfer files using FTP with error checking
  $ autoload -U zfinit ; zfinit
  $ zftp open host.name.invalid user passwd || exit
  $ zftp get /remote/file &gt; /local/file; r=$?
  $ zftp close &amp;&amp; exit r

# compress and ftp on the fly
  $ autoload -U zfinit ; zfinit
  $ zftp open host.name.invalid user password
  $ zftp get $file | bzip2 &gt; ${file}.bz2
  $ zftp close

# Recursice ``get''
  $ autoload -U zfinit ; zfinit
  $ zfanon cr.yp.to
  $ zfcd daemontools
  $ for file in `zfls` ; do
  &gt;     zfget $file
  $ done
  $ zfclose

# Upload all regular files in $HOME/foobar (recursive) that are newer than
# two hours to ftp.foobar.invalid/path/to/upload
  $ autoload -U zfinit ; zfinit
  $ zfopen ftp.foobar.invalid/path/to/upload
  $ cd $HOME/foobar
  $ zfput -r **/*(.mh-2)
  $ zfclose

# long list of files on a ftp
  $ autoload -U zfinit ; zfinit
  $ zfopen some-host
  $ zfcd /some/remote/Dir
  $ cd /some/local/Dir
# If the list.txt is located on the remote host, change to
# zfget ${(f)"$(zftp get /path/to/remote/list.txt)"}
  $ zfget ${(f)"$(cat list.txt)"}
  $ zfclose</tt></pre>
</div></div>
<h4>zsh/zselect (require zmodload zsh/zselect)</h4>
<div class="listingblock">
<div class="content">
<pre><tt># It's similar to
 ,----
 | $ sg=$(stty -g)
 | $ stty -icanon min 0 time 50
 | $ read yesno
 | $ stty "$sg"
 | $ case "$yesno" in
 | &gt;  yes) command1;;
 | &gt;  *) command2;;
 | &gt; esac
 `----
$ zmodload zsh/zselect
$ if zselect -t 500 -r 0 &amp;&amp; read yesno &amp;&amp; [ yes = "$yesno" ]; then
&gt;    command1
&gt; else
&gt;    command1
&gt; fi</tt></pre>
</div></div>
</div>
<h2>OPTIONS</h2>
<div class="sectionbody">
<h3>Navigation options</h3>
<p><strong>auto_cd</strong> (allow one to change to a directory by entering it as a
command). <strong>auto_pushd</strong> (automatically append dirs to the push/pop list)
pushd_ignore_dups (and don't duplicate them).</p>
<h3>Misc</h3>
<p><strong>no_hup</strong> (don't send  HUP signal to background jobs when exiting ZSH).
<strong>print_exit_value</strong> (show a message with the exit code when a command
returns with a non-zero exit code)</p>
<h4>History options</h4>
<p><strong>hist_verify</strong> (let the user edit the command line after history
expansion (e.g. !ls) instead of immediately running it) <tt>
Use the same history file for all sessions : </tt>
<strong>setopt SHARE_HISTORY</strong></p>
<h4>Privacy / Security</h4>
<p><strong>no_clobber</strong>  (or set -C; prevent <em>&gt;</em> redirection from truncating
the given file if it already exists)</p>
<h4>Spelling correction</h4>
<p><strong>correct</strong> (automatically correct the spelling of commands).
<strong>correct_all</strong> (automatically correct the spelling of each word on the
command line) <strong>dvorak</strong> (dvorak layout)</p>
</div>
<h2>UNSORTED/MISC</h2>
<div class="sectionbody">
<p>Mailpath: simple multiple mailpath:</p>
<div class="listingblock">
<div class="content">
<pre><tt>mailpath=($HOME/Mail/mbox'?new mail in mbox'
          $HOME/Mail/tux.u-strasbg'?new mail in tux'
          $HOME/Mail/lilo'?new mail in lilo'
          $HOME/Mail/ldap-fr'?new mail in ldap-fr')</tt></pre>
</div></div>
<p>Mailpath: dynamic mailpath:</p>
<div class="listingblock">
<div class="content">
<pre><tt>typeset -a mailpath
for i in ~/Mail/Lists/*(.); do
   mailpath[$#mailpath+1]="${i}?You have new mail in ${i:t}."
done</tt></pre>
</div></div>
<p>Avoid globbing on special commands:</p>
<div class="listingblock">
<div class="content">
<pre><tt>for com in alias expr find mattrib mcopy mdir mdel which;
alias $com="noglob $com"</tt></pre>
</div></div>
<p>For migrating your bashprompt to zsh use the script bash2zshprompt located in
the zsh source distribution under <em>Misc</em>.</p>
<p>For migration from (t)csh to zsh use the c2z tool that converts csh
aliases and environment and shell variables to zsh. It does this by running
csh, and having csh report on aliases and variables. The script then converts
these to zsh startup files. It has some issues and usage information that are
documented at the top of this script.</p>
<p>Here are functions to set the title and hardstatus of an <strong>XTerm</strong> or of <strong>GNU
Screen</strong> to <em>zsh</em> and the current directory, respectively, when the prompt is
displayed, and to the command name and rest of the command line, respectively,
when a command is executed:</p>
<div class="listingblock">
<div class="content">
<pre><tt>function title {
      if [[ $TERM == "screen" ]]; then
        # Use these two for GNU Screen:
        print -nR $' 33k'$1$' 33'\
        print -nR $' 33]0;'$2$''
      elif [[ $TERM == "xterm" || $TERM == "rxvt" ]]; then
        # Use this one instead for XTerms:
        print -nR $' 33]0;'$*$''
      fi
}
function precmd { title zsh "$PWD" }
function preexec {
    emulate -L zsh
    local -a cmd; cmd=(${(z)1})
    title $cmd[1]:t "$cmd[2,-1]"
}</tt></pre>
</div></div>
<p>Put the following line into your ~/.screenrc to see this fancy hardstatus:</p>
<div class="listingblock">
<div class="content">
<pre><tt>caption always "%3n %t%? (%u)%?%?: %h%?"</tt></pre>
</div></div>
<p>Special variables which are assigned:</p>
<div class="listingblock">
<div class="content">
<pre><tt>$LINENO $RANDOM $SECONDS $COLUMNS $HISTCHARS $UID
$EUID $GID $EGID $USERNAME $fignore $mailpath $cdpath</tt></pre>
</div></div>
</div>
<h2>LINKS</h2>
<div class="sectionbody">
<dl>
<dt>
Primary site
</dt>
<dd>
<p>
  <strong><a href="http://www.zsh.org/">http://www.zsh.org/</a></strong>
</p>
</dd>
<dt>
Project-page
</dt>
<dd>
<p>
  <strong><a href="http://sourceforge.net/projects/zsh/">http://sourceforge.net/projects/zsh/</a></strong>
</p>
</dd>
<dt>
Z shell page at sunsite.dk
</dt>
<dd>
<p>
    <strong><a href="http://zsh.sunsite.dk/">http://zsh.sunsite.dk/</a></strong>
</p>
</dd>
<dt>
From Bash to Z Shell: Conquering the Command Line - the book
</dt>
<dd>
<p>
    <strong><a href="http://www.bash2zsh.com/">http://www.bash2zsh.com/</a></strong>
</p>
</dd>
<dt>
Mailinglistarchive
</dt>
<dd>
<p>
    <strong><a href="http://www.zsh.org/mla/">http://www.zsh.org/mla/</a></strong>
</p>
</dd>
<dt>
ZSH-FAQ
</dt>
<dd>
<p>
    <strong><a href="http://www.zsh.org/FAQ/">http://www.zsh.org/FAQ/</a></strong>
</p>
</dd>
<dt>
Userguide
</dt>
<dd>
<p>
    <strong><a href="http://zsh.sunsite.dk/Guide/">http://zsh.sunsite.dk/Guide/</a></strong>
</p>
</dd>
<dt>
ZSH-Wiki
</dt>
<dd>
<p>
    <strong><a href="http://www.zshwiki.org/">http://www.zshwiki.org/</a></strong>
</p>
</dd>
<dt>
Die Zsh als interaktive Shell
</dt>
<dd>
<p>
    <strong><a href="http://cssun.rrze.uni-erlangen.de/~sipakale/zshreferat.html">http://cssun.rrze.uni-erlangen.de/~sipakale/zshreferat.html</a></strong>
</p>
</dd>
<dt>
A short introduction from BYU
</dt>
<dd>
<p>
    <strong><a href="http://docs.cs.byu.edu/docs/zsh/index.php">http://docs.cs.byu.edu/docs/zsh/index.php</a></strong>
</p>
</dd>
<dt>
Mouse-Support ;)
</dt>
<dd>
<p>
    <strong><a href="http://stchaz.free.fr/mouse.zsh">http://stchaz.free.fr/mouse.zsh</a></strong>
</p>
</dd>
<dt>
Shell Corner: Zsh Suite of "keeper" Functions
</dt>
<dd>
<p>
    <strong><a href="http://www.unixreview.com/documents/s=9513/ur0501a/ur0501a.htm">http://www.unixreview.com/documents/s=9513/ur0501a/ur0501a.htm</a></strong>
</p>
</dd>
<dt>
The Z Shell (A Fan Page)
</dt>
<dd>
<p>
    <strong><a href="http://www.princeton.edu/~kmccarty/zsh.html">http://www.princeton.edu/~kmccarty/zsh.html</a></strong>
</p>
</dd>
<dt>
Making the Transition to Zsh
</dt>
<dd>
<p>
    <strong><a href="http://www.linux-mag.com/cgi-bin/printer.pl?issue=2002-05&amp;article=power">http://www.linux-mag.com/cgi-bin/printer.pl?issue=2002-05&amp;article=power</a></strong>
</p>
</dd>
<dt>
Curtains up: introducing the Z shell
</dt>
<dd>
<p>
    <strong><a href="http://www-128.ibm.com/developerworks/linux/library/l-z.html?dwzone=linux">http://www-128.ibm.com/developerworks/linux/library/l-z.html?dwzone=linux</a></strong>
</p>
</dd>
<dt>
ZSH-Liebhaberseite
</dt>
<dd>
<p>
    <strong><a href="http://michael-prokop.at/computer/tools_zsh_liebhaber.html">http://michael-prokop.at/computer/tools_zsh_liebhaber.html</a></strong>
</p>
</dd>
<dt>
ZSH-Seite von Michael Prokop
</dt>
<dd>
<p>
    <strong><a href="http://www.michael-prokop.at/computer/tools_zsh.html">http://www.michael-prokop.at/computer/tools_zsh.html</a></strong>
</p>
</dd>
<dt>
A Case for the Z Shell on <strong><a href="http://www.daemonnews.org/">http://www.daemonnews.org/</a></strong>
</dt>
<dd>
<p>
    <strong><a href="http://ezine.daemonnews.org/199910/zsh.html">http://ezine.daemonnews.org/199910/zsh.html</a></strong>
</p>
</dd>
<dt>
ZSH-Section from Dotfiles.com
</dt>
<dd>
<p>
    <strong><a href="http://www.dotfiles.com/index.php?app_id=4">http://www.dotfiles.com/index.php?app_id=4</a></strong>
</p>
</dd>
<dt>
Writing Zsh Completion Functions
</dt>
<dd>
<p>
    <strong><a href="http://www.linux-mag.com/2002-07/power_01.html">http://www.linux-mag.com/2002-07/power_01.html</a></strong>
</p>
</dd>
<dt>
ZSH Prompt introduction
</dt>
<dd>
<p>
    <strong><a href="http://aperiodic.net/phil/prompt/">http://aperiodic.net/phil/prompt/</a></strong>
</p>
</dd>
<dt>
Adam's ZSH page
</dt>
<dd>
<p>
    <strong><a href="http://www.adamspiers.org/computing/zsh/">http://www.adamspiers.org/computing/zsh/</a></strong>
</p>
</dd>
<dt>
Zzappers Best of ZSH Tips
</dt>
<dd>
<p>
    <strong><a href="http://www.rayninfo.co.uk/tips/zshtips.html">http://www.rayninfo.co.uk/tips/zshtips.html</a></strong>
</p>
</dd>
<dt>
Zsh Webpage by Christian Schneider
</dt>
<dd>
<p>
    <strong><a href="http://strcat.de/wiki/zsh/">http://strcat.de/wiki/zsh/</a></strong>
    <strong><a href="http://strcat.de/wiki/zsh-german">http://strcat.de/wiki/zsh-german</a></strong> (German translation. Help needed!)
</p>
</dd>
<dt>
The zsh-lovers webpage
</dt>
<dd>
<p>
    <strong><a href="http://grml.org/zsh/">http://grml.org/zsh/</a></strong>
</p>
</dd>
<dt>
IRC channel
</dt>
<dd>
<p>
    <strong>#zsh at irc.freenode.org</strong>
</p>
</dd>
<dt>
The Z shell reference-card (included in the zsh-lovers debian-package)
</dt>
<dd>
<p>
    <strong><a href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></strong>
</p>
</dd>
</dl>
</div>
<h2>AUTHORS</h2>
<div class="sectionbody">
<p>This manpage was written by Michael Prokop, Christian <em>strcat</em>
Schneider and Matthias Kopfermann. But many ideas have been taken from
zsh-geeks e.g. from the zsh-mailinglists (zsh-users and zsh-workers),
google, newsgroups and the zsh-Wiki.<br />
Thanks for your cool and incredible tips. We learned much from you!</p>
<p>In alphabetic order:</p>
<div class="listingblock">
<div class="content">
<pre><tt>Andrew 'zefram' Main  - http://www.fysh.org/~zefram/
Barton E. Schaefer    - http://www.well.com/user/barts/
Matthias Kopfermann   - http://www.infodrom.north.de/~matthi/
Oliver Kiddle         - http://people.freenet.de/opk/
Paul Falstad          - http://www.falstad.com/
Peter Stephenson      - http://homepage.ntlworld.com/p.w.stephenson/
Richard Coleman
Stephane Chazelas     - http://stephane.chazelas.free.fr/
Sven Guckes           - http://www.guckes.net/
Sven Wischnowsky      - http://w9y.de/zsh/zshrc</tt></pre>
</div></div>
</div>
<h2>SEE ALSO</h2>
<div class="sectionbody">
<p>Manpages of zsh:</p>
<div class="listingblock">
<div class="content">
<pre><tt>       zsh          Zsh overview
       zshall       Tthe Z shell meta-man page
       zshbuiltins  Zsh built-in commands
       zshcalsys    zsh calendar system
       zshcompctl   zsh programmable completion
       zshcompsys   Zsh completion system
       zshcompwid   Zsh completion widgets
       zshcontrib   User contributions to zsh
       zshexpn      Zsh expansion and substitution
       zshmisc      Anything not fitting into the other sections
       zshmodules   Zsh loadable modules
       zshoptions   Zsh options
       zshparam     Zsh parameters
       zshroadmap   Informal introduction to the zsh manual
       zshtcpsys    Zsh tcp system
       zshzle       Zsh command line editing
       zshzftpsys   Zsh built-in FTP client
       zshall       Meta-man page containing all of the above</tt></pre>
</div></div>
<p>Note: especially <em>man zshcontrib</em> covers very useful topics! <tt>
Book: <strong>From Bash to Z Shell</strong> by Oliver Kiddle, Jerry Peck and Peter
Stephenson. <strong>ISBN: 1590593766</strong>. - <strong><a href="http://www.bash2zsh.com/">bash2zsh.com</a></strong> </tt>
Also take a look at the section <strong>LINKS</strong> in this manpage.</p>
</div>
<h2>BUGS</h2>
<div class="sectionbody">
<p>Probably. This manpage might be never complete. So please report bugs,
feedback and suggestions to &lt;zsh-lovers@michael-prokop.at&gt;. Thank
you!</p>
</div>
<h2>COPYRIGHT</h2>
<div class="sectionbody">
<p>Copyright  (C) Michael Prokop, Christian Schneider and Matthias
Kopfermann.</p>
</div>
<div id="footer">
<div id="footer-text">
Last updated 01-Nov-2009 04:31:39 CEST
</div>
</div>
</body>
</html>
